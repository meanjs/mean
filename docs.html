<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
<!--<![endif]-->

<head>
	<title>MEAN.JS Documentation</title>

	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="description" content="MEAN.JS - Full-Stack JavaScript Using MongoDB, Express, AngularJS, and Node.js.">
	<meta name="keywords" content="mean, mean stack,mean.js,meanjs,mean node,mean angular,mean mongo,mean express,mongodb,express,angularjs,node.js,node,angular,express,mongo,documentation,mean docs">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta name="twitter:card" content="summary">
	<meta name="twitter:site" content="@meanjsorg">
	<meta name="twitter:title" content="MEAN.JS - Full-Stack JavaScript Boilerplate From Creators of MEAN.IO.">
	<meta name="twitter:description" content="MEAN.JS - Full-Stack JavaScript Using MongoDB, Express, AngularJS, and Node.js.">
	<meta name="twitter:image:src" content="http://meanjs.org/img/icon.png">

	<meta property="og:title" content="MEAN.JS - Full-Stack JavaScript Boilerplate From Creators of MEAN.IO." />
	<meta property="og:description" content="MEAN.JS - Full-Stack JavaScript Using MongoDB, Express, AngularJS, and Node.js." />
	<meta property="og:image" content="http://meanjs.org/img/icon.png" />
	<meta property="og:url" content="http://meanjs.org" />

	<link rel="shortcut icon" href="img/favicon.ico" />
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,600,700,800,300' rel='stylesheet' type='text/css'>


	<link rel="stylesheet" href="css/bootstrap-journal.min.css">
	<link rel="stylesheet" href="css/common.css">
</head>

<body data-spy="scroll" data-target=".nav-docs">
	<header class="navbar navbar-default navbar-fixed-top" role="banner">
		<div class="container">
			<div class="navbar-header">
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a href="http://meanjs.org" class="logo-container">
					<img src="img/logo.png" alt="MEAN.JS" height="40">
				</a>
			</div>
			<nav id="navbar" class="collapse navbar-collapse" role="navigation">
				<ul class="nav navbar-nav navbar-right">
					<li class="active">
						<a href="docs.html">Docs</a>
					</li>
					<li>
						<a href="generator.html">Yo Generator</a>
					</li>
					<li>
						<a href="modules.html">Modules</a>
					</li>
					<li>
						<a href="changelog.html">Changelog</a>
					</li>
					<li>
						<a href="community.html">Community</a>
					</li>
					<li>
						<a target="_blank" href="http://blog.meanjs.org">Blog</a>
					</li>
				</ul>
			</nav>
		</div>
	</header>
	<section class="content">
		<section class="container">
			<section class="row">
				<div class="col-md-2">
					<nav class="nav-docs" role="complementary">
						<ul class="nav nav-pills nav-stacked">
							<li>
								<a href="#overview">Overview</a>
							</li>
							<li>
								<a href="#getting-started">Getting Started</a>
							</li>
							<li>
								<a href="#troubleshooting">Troubleshooting</a>
							</li>
							<li>
								<a href="#folder-structure">Folder Structure</a>
							</li>
							<li>
								<a href="#configuration">Configuration</a>
							</li>
							<li>
								<a href="#autoload">Autoloaded Files</a>
							</li>
							<li>
								<a href="#npm">NPM</a>
							</li>
							<li>
								<a href="#bower">Bower</a>
							</li>
							<li>
								<a href="#grunt">Grunt</a>
							</li>
							<li>
								<a href="#express">Express &amp; Routing</a>
							</li>
							<li>
								<a href="#passport">Passport</a>
							</li>
							<li>
								<a href="#backend-views">Backend Views</a>
							</li>
							<li>
								<a href="#server-tests">Server Tests</a>
							</li>
							<li>
								<a href="#angularjs-tests">AngularJS Tests</a>
							</li>
							<li>
								<a href="#angularjs-modules">AngularJS Modules</a>
							</li>
							<li>
								<a href="#menus">AngularJS Menus Service</a>
							</li>
							<li>
								<a href="#article-example">The Article Example</a>
							</li>
						</ul>
					</nav>
				</div>
				<section class="col-md-10 col-md-offset-2">
					<i class="small text-muted">
						Last updated: 03 Aug 2014.
					</i>

					<div class="inner-link-anchor" id="overview"></div>
					<section class="page-header">
						<h1>Overview</h1>
					</section>
					<section>
						Thank you for downloading the MEAN.JS boilerplate!
						<br>
						<br>This simple documentation will cover the basics of developing your MEAN application.
						<br>
						<br>Before you begin we recommend you read about the basic building blocks that assemble a MEAN.JS application:
						<br>
						<br>
						<dl>
							<dt>MongoDB</dt>
							<dd>
								Go through <a target="_blank" href="http://mongodb.org">MongoDB Official Website</a> and proceed to its <a target="_blank" href="http://docs.mongodb.org/manual/">Great Manual</a>, which should help you understand NoSQL and MongoDB better.
							</dd>
							<dt>Express</dt>
							<dd>
								The best way to understand express is through its <a target="_blank" href="http://expressjs.com"> Official Website</a>, particularly <a target="_blank" href="http://expressjs.com/guide.html">The Express Guide</a>; you can also go through this <a target="_blank" href="http://stackoverflow.com/questions/8144214/learning-express-for-node-js">StackOverflow Thread</a> for more resources.
							</dd>
							<dt>AngularJS</dt>
							<dd>
								Angular's <a target="_blank" href="http://angularjs.org">Official Website</a> is a great starting point. You can also use <a target="_blank" href="http://www.thinkster.io/">Thinkster Popular Guide</a>, and the <a target="_blank" href="https://egghead.io/">Egghead Videos</a>.
							</dd>
							<dt>Node.js</dt>
							<dd>
								Start by going through <a target="_blank" href="http://nodejs.org">Node.js Official Website</a> and this <a target="_blank" href="http://stackoverflow.com/questions/2353818/how-do-i-get-started-with-node-js">StackOverflow Thread</a>, which should get you going with the Node.js platform in no time.
							</dd>
						</dl>
						When you're done with those resources and feel you understand the basic principals continue to other sections.
						<br>
						<br>Enjoy &amp; keep us updated,
						<br>The MEAN.JS Team.
					</section>
					<div class="inner-link-anchor" id="getting-started"></div>
					<section class="page-header">
						<h1>Getting Started</h1>
					</section>
					<section>
						<p>
							In this section you'll learn how to get started with a MEAN.JS application, install all the prerequisites, and initialize your application.
						</p>
						<h2>Prerequisites</h2>
						<p>
							Before you begin, you should make sure you have installed all these prerequisites on your development machine.
						</p>
						<br>
						<dl class="dl-horizontal">
							<dt>Node.js &amp; npm</dt>
							<dd>
								<a target="_blank" href="http://www.nodejs.org/download">Download &amp; Install</a> Node.js and the npm package manager, if you encounter any problems, you can also use this <a target="_blank" href="https://gist.github.com/isaacs/579814">Github Gist</a> to install Node.js.
							</dd>
							<dt>MongoDB</dt>
							<dd>
								<a target="_blank" href="http://www.mongodb.org/downloads">Download &amp; Install</a> MongoDB, and make sure it's running on the default port (27017).
							</dd>
							<dt>Bower</dt>
							<dd>
								You're going to use the <a target="_blank" href="http://bower.io">Bower Package Manager</a> to manage your front-end packages, in order to install it make sure you've installed Node.js and npm, then install bower globally using npm:
								<pre>$ npm install -g bower</pre>
							</dd>
							<dt>Grunt</dt>
							<dd>
								You're going to use the <a target="_blank" href="http://gruntjs.com/">Grunt Task Runner</a> to automate your development process, in order to install it make sure you've installed Node.js and npm, then install grunt globally using npm:
								<pre>$ npm install -g grunt-cli</pre>
							</dd>
						</dl>
						<p class="alert alert-info">
							<b>Note:</b> Your user might not have the permissions to install package globally, so use a super user or <b>sudo</b>.
						</p>
						<h2>Downloading MEAN.JS</h2>
						<p>
							There are several ways you can get the MEAN.JS boilerplate:
						</p>
						<h3>Yo Generator</h3>
						<p>The recommended way would be to use the <a href="http://meanjs.org/generator.html">official Yo Generator</a> which will generate the latest stable copy of the MEAN.JS boilerplate and supply multiple sub-generators to ease your daily development cycles.
						</p>
						<p class="alert alert-info">
							<b>Note:</b> If you want to support
							<em>git merge</em>updates it would be better to use
							<em>git clone</em>for your initial project creation, don't worry you'd still be able use the generator.
						</p>
						<h3>Cloning The GitHub Repository</h3>
						<p>
							You can also use Git to directly clone the MEAN.JS repository:
						</p>
						<pre>$ git clone https://github.com/meanjs/mean.git meanjs</pre>
						<p>
							This will clone the latest version of the MEAN.JS repository to a meanjs folder.
						</p>
						<h3>Downloading The Repository Zip File</h3>
						<p>
							Another way to use the MEAN.JS boilerplate is to download a zip copy from the master branch on github. You can also do this using wget command:
						</p>
						<pre>$ wget https://github.com/meanjs/mean/archive/master.zip -O meanjs.zip; unzip meanjs.zip; rm meanjs.zip</pre>
						<p>
							Don't forget to rename mean-master after your project name.
						</p>
						<h2>Quick Install</h2>
						<p>
							Once you've installed all the prerequisites, you're just a few steps away from starting to develop you MEAN application.
						</p>
						<p>
							The first thing you should do is install the Node.js dependencies. The boilerplate comes pre-bundled with a <b>package.json</b> file that contains the list of modules you need to start your application, to learn more about the modules installed visit the <a href="#npm">NPM &amp; Package.json</a> section.
						</p>
						<p>
							To install Node.js dependencies you're going to use npm again, just run this in the command-line:
							<pre>$ npm install</pre>
							<br>This command does a few things:
							<ul>
								<li>First it will install the dependencies needed for the application to run.</li>
								<li>If you're running in a development environment, it will then also install development dependencies needed for testing and running your application.</li>
								<li>Finally, when the install process is over, npm will initiate a
									<code>bower install</code>command to install all the front-end modules needed for the application.</li>
							</ul>
						</p>
						<h2>Running Your Application</h2>
						<p>
							After the install process is over, you'll be able to run your application using Grunt, just run grunt default task:
							<pre>$ grunt</pre>
							Your application should run on the 3000 port so in your browser just go to <a target="_blank" href="http://localhost:3000">http://localhost:3000</a>.
						</p>
						<p>
							That's it! your application should be running by now, to proceed with your development check the other sections in this documentation.
							<br>If you encounter any problem try the <a href="#troubleshooting">Troubleshooting</a> section.
						</p>
					</section>
					<div class="inner-link-anchor" id="troubleshooting"></div>
					<section class="page-header">
						<h1>Troubleshooting</h1>
					</section>
					<section>
						During the installation process you may encounter some problems, so what can you do?

						<h2>Check Node.js and npm Versions</h2>
						<p>
							The rapid advancements in JavaScript modules can sometimes cause version issues with the MEAN's dependencies. We try to keep up with the stable versions, and make sure the modules versions are compatible with those versions. We can't control the pre-installed platforms versions, so make sure you didn't install unsupported versions of Node.js and MongoDB.
						</p>
						<dl>
							<dt>MongoDB</dt>
							<dd>
								MongoDB version 2.4.x is supported.
							</dd>
							<dt>Node.js</dt>
							<dd>
								Node version 0.10.x is supported.
							</dd>
							<dt>npm</dt>
							<dd>
								npm version 1.3.x is supported.
							</dd>
						</dl>
						<h2>Update npm, Bower or Grunt</h2>
						<p>
							You may find there is a weird error during install like npm's Error: ENOENT, usually updating those tools to the latest version solves the issue.
						</p>
						<dl>
							<dt>Updating npm</dt>
							<dd>
								To update npm just run this command in the command-line:
								<pre>$ npm update -g npm</pre>
							</dd>
							<dt>Updating Bower</dt>
							<dd>
								To update bower just run this command in the command-line:
								<pre>$ npm update -g bower</pre>
							</dd>
							<dt>Updating Grunt</dt>
							<dd>
								To update grunt just run this command in the command-line:
								<pre>$ npm update -g grunt-cli</pre>
							</dd>
						</dl>
						<h2>Cleaning npm and Bower cache</h2>
						<p>
							Both npm and Bower uses a caching system that caches the packages you already installed. Often cleaning npm &amp; Bower's cache can solve some of the issues you encounter during the installation process.
						</p>
						<dl>
							<dt>Cleaning npm's cache</dt>
							<dd>
								To clean npm's cache just run this command in the command-line:
								<pre>$ npm cache clean</pre>
							</dd>
							<dt>Cleaning Bower's cache</dt>
							<dd>
								To clean bower's cache just run this command in the command-line:
								<pre>$ bower cache clean</pre>
							</dd>
						</dl>
						<h2>Common Issues</h2>
						<p>
							There are some common errors while installing mean:
						</p>
						<dl>
							<dt>Node is running but AgnularJS application won't load</dt>
							<dd>
								Check to see all your front-end packages were installed.
								<a target="_blank" href="https://bower.io/">Bower</a> package manager is used to install the front-end package and it will need a <a target="_blank" href="http://bower.io/#configuration">.bowerrc</a> file to install the packages in the right location.
								<br>Bower should install the packages in the <b>public/lib</b> folder, so if this folder or some of its sub-folders doesn't exist, run:
								<pre>$ bower update</pre>
								This will install the missing packages.
							</dd>
							<dt>Error: failed to connect to [localhost:27017]</dt>
							<dd>
								If you use a local MongoDB check to see if its running. In case you use an external service verify the URI in the <a href="#configuration">configuration files</a>.
							</dd>
						</dl>
						<p class="alert alert-warning">
							Sometimes it can be a local issue or something that we didn't cover, in case you have any further questions please contact us via the community page.
						</p>
					</section>
					<div class="inner-link-anchor" id="folder-structure"></div>
					<section class="page-header">
						<h1>Folder Structure</h1>
					</section>
					<section>
						<p>
							The folder structure is quite self-explanatory, but here's an explanation on what goes where and why.
						</p>
						<h2>App</h2>
						<p>
							The server folder contains all the server files you use in your application, this is where you store your MVC server files.
						</p>
						<ul>
							<li>
								<h3>controllers</h3>
								The controllers folder is where you store your Express application controllers, this is where you write your backend business logic.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove Express application controllers.
								</p>
							</li>
							<li>
								<h3>models</h3>
								<a href="#autoload" class="label label-danger">Autoloaded</a> 
								<br>The models folder is where you store your <a target="_blank" href="http://mongoosejs.com/">Mongoose</a> models, this is where you define your backend models.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove Mongoose models.
								</p>
							</li>
							<li>
								<h3>routes</h3>
								<a href="#autoload" class="label label-danger">Autoloaded</a> 
								<br>The routes folder contains the <b>Server routing</b> configuration files, this is where you define your Express routes, in order to add routes to your module just add a .js file similar to the <b>app/routes/articles.js</b> file and MEAN will automatically load that these routes.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove a server route.
								</p>
							</li>
							<li>
								<h3>tests</h3>
								The tests folder is where you store your <a target="_blank" href="http://visionmedia.github.io/mocha/">Mocha</a> tests, this is how you test your backend business logic.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove Mocha tests.
								</p>
							</li>
							<li>
								<h3>views</h3>
								The views folder is where define your backend views. Since you'll use AngularJS, server templates are almost meaningless, but you still have to use a template engine to render the main pages, like the index and error pages. For more information visit the <a href="#backend-views">Backend Views</a> section.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove backend views.
								</p>
								<ul>
									<li>
										<h3>templates</h3>
										A backend templates folder, currently used for emails templates.
										<p class="alert alert-info">
											<b>When to use:</b>
											Whenever you want to add, change, or remove backend templates.
										</p>
									</li>
								</ul>
							</li>
						</ul>
						<h2>Config</h2>
						<p>
							The config folder contains the files you need to configure your application.
						</p>
						<ul>
							<li>
								<h3>env</h3>
								The <b>env</b> folder contains the configuration files loaded by the <b>config.js</b> file according to the current environment, for more information, please visit the <a href="#configuration">Configuration</a> section.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove your configuration properties.
								</p>
							</li>
							<li>
								<h3>strategies</h3>
								<a href="#autoload" class="label label-danger">Autoloaded</a> 
								<br>The <b>strategies</b> folder contains the startegies configuration files loaded by the <b>passport.js</b> file.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove a <a target="_blank" href="http://passportjs.org/guide/providers/">Passport Strategy</a>.
								</p>
							</li>
							<li>
								<h3>config.js</h3>
								The configuration loader that loads the right configuration from the <b>env</b> folder, for more information, please visit the <a href="#configuration">Configuration</a> section.
							</li>
							<li>
								<h3>express.js</h3>
								Express configuration file, it initializes &amp; configures the Express application.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to change the way Express is being initialized and configured.
								</p>
							</li>
							<li>
								<h3>init.js</h3>
								The initialization file that set up a few project related configuraiton.
							</li>
							<li>
								<h3>passport.js</h3>
								Passport configuration file that initializes &amp; configures the Passport's authentication strategies and middlewares from the <b>strategies</b> folder.
							</li>
						</ul>
						<h2>Public</h2>
						<p>
							The public folder contains all the static files you use in your application, this is where you store your front-end files.
						</p>
						<ul>
							<li>
								<h3>dist</h3>
								The distribution folder is where you store your application compressed CSS and JavaScript assets. The <b>uglify</b> and <b>cssmin</b> grunt tasks are using this as their build target folder.
							</li>
							<li>
								<h3>modules</h3>
								<a href="#autoload" class="label label-danger">Autoloaded</a> 
								<br>The modules folder is where you store AngularJS application modules, to learn more about it visit the <a href="#angularjs-modules">AngularJS Modules</a> section.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove AngularJS modules.
								</p>
							</li>
							<li>
								<h3>config.js</h3>
								AngularJS configuration module, it starts with two global properties and one method:
								<dl>
									<dt>applicationModuleName</dt>
									<dd>
										AngularJS is using a module system to bootstrap and application, in this case it will use this property as the main module name.
									</dd>
									<dt>applicationModuleVendorDependencies</dt>
									<dd>
										AngularJS allows to add dependencies to the main module forcing the application not to start if those dependencies aren't met. In this case we start with the basic AngularJS &amp; Angular-UI dependencies, each third-party module you add to your application should be added to the <i>applicationModuleVendorDependencies</i> global property and AngularJS will load it automatically.
									</dd>
									<dt>registerModule</dt>
									<dd>
										This method is used to register a module as a new module and add it to the main module dependencies.
										<p class="alert alert-danger">
											Although you don't have to, it is highly recommended that you use <b>registerModule</b> method to reigster your module as a dependency for the main application module. To understand this better please visit the <a href="#angularjs-modules">AngularJS Modules</a> section.
										</p>
									</dd>
								</dl>
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove an AngularJS global configuration property.
								</p>
							</li>
							<li>
								<h3>application.js</h3>
								AngularJS main application file, it takes care of bootstrapping the application and attaching the right modules.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove a module in your AngularJS application.
								</p>
							</li>
						</ul>
						<h2>Application Files</h2>
						<p>
							There are a few application files stored in root folder.
						</p>
						<ul>
							<li>
								<h3>server.js</h3>
								Our main application file, where you initialize your Node.js application.
							</li>
							<li>
								<h3>bower.json</h3>
								Bower <a target="_blank" href="http://bower.io/#defining-a-package">definition file</a>, where you configure the front-end components you want to use, for more information visit the <a href="#bower">Bower</a> section.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove front-end components.
								</p>
							</li>
							<li>
								<h3>Dockerfile</h3>
								<a target="_blank" href="https://www.docker.com/">Docker</a> <a target="_blank" href="https://docs.docker.com/reference/builder/">configuration file</a>, where you configure all the commands you would normally execute manually in order to build a Docker image.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to configure your Docker images.
								</p>
							</li>
							<li>
								<h3>fig.yml</h3>
								<a target="_blank" href="https://www.docker.com/">Docker</a> development environment <a target="_blank" href="http://www.fig.sh/yml.html">configuration file</a>, where you configure your application environment with Docker .
							</li>
							<li>
								<h3>gruntfile.js</h3>
								Grunt <a target="_blank" href="http://gruntjs.com/sample-gruntfile">definition file</a> is where you define your grant tasks, for more information visit the <a href="#grunt">Grunt</a> section.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove grunt tasks.
								</p>
							</li>
							<li>
								<h3>karma.conf.js</h3>
								Karma <a target="_blank" href="http://karma-runner.github.io/0.8/config/configuration-file.html">configuration file</a> is where you configure your karma tests.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove front-end tests.
								</p>
							</li>
							<li>
								<h3>package.json</h3>
								npm <a target="_blank" href="https://npmjs.org/doc/json.html">definition file</a>, where you configure the backend modules you want to use, for more information visit the <a href="#npm">NPM</a> section.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove backend modules.
								</p>
							</li>
							<li>
								<h3>Procfile</h3>
								Heroku <a target="_blank" href="https://devcenter.heroku.com/articles/procfile">process file</a>, where you configure process you want to run on Heroku application Dyno.
							</li>
						</ul>
						<h2>Hidden Configuration Files</h2>
						<p class="alert alert-danger">
							Notice that sometimes you copy your application folder's content and forget to copy the hidden files, this will cause issues and might break the application.
						</p>
						<ul>
							<li>
								<h3>.bowerrc</h3>
								Bower configuration file, you use it to tell bower where to install your application components.
							</li>
							<li>
								<h3>.csslintrc</h3>
								<a target="_blank" href="http://csslint.net/">CSSLint</a> configuration file, you use it to configure CSSLint special properties.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove CSSLint properties.
								</p>
							</li>
							<li>
								<h3>.editconfig</h3>
								<a target="_blank" href="http://editorconfig.org/">EditorConfig</a> configuration file, you use it to configure consistent coding styles between different editors and IDEs.
							</li>
							<li>
								<h3>.gitignore</h3>
								Git <a target="_blank" href="https://help.github.com/articles/ignoring-files">ignore file</a>, you use it to tell git what <b>ignore</b> in next commits. After installation the application generates a lot of code that you don't want to include in your repository, so this is where you tell git to ignore those files.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove files that are ignored by Git.
								</p>
							</li>
							<li>
								<h3>.jshintrc</h3>
								<a target="_blank" href="http://www.jshint.com/">JSHint</a> configuration file, you use it to configure JSHint special properties.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove JSHint properties.
								</p>
							</li>
							<li>
								<h3>.slugignore</h3>
								Heroku <a target="_blank" href="https://devcenter.heroku.com/articles/slug-compiler#ignoring-files-with-slugignore">ignore file</a>, you use it to tell Heroku slug compiler what <b>ignore</b> in next commits, which will prevent oversizing your final slug.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove files that are ignored by Heroku slug compiler.
								</p>
							</li>
							<li>
								<h3>.travis.yml</h3>
								Travis <a target="_blank" href="http://about.travis-ci.org/docs/user/build-configuration/">configuration file</a>, you use it to tell Travis how you want your builds to be executed.
								<p class="alert alert-info">
									<b>When to use:</b>
									Whenever you want to add, change, or remove TravisCI configuration options.
								</p>
							</li>
						</ul>
					</section>
					<div class="inner-link-anchor" id="configuration"></div>
					<section class="page-header">
						<h1>Configuration</h1>
					</section>
					<section>
						<p>
							So, you have your application running, but how do you configure it?
						</p>
						<h2>Environmental Configuration</h2>
						<p>
							The config folder is where you have all the files are organized in a specific structure, which starts with the <b>config.js</b> file.
						</p>
						<p>
							The config file functions as loader for the configurations files placed in the <b>config/env</b> folder, it will load the right configuration file based on the NODE_ENV variable.
						</p>
						<br>
						<p>
							There are five default configuration files based on common development pattern:
						</p>
						<dl>
							<dt>config/env/all.js</dt>
							<dd>
								This file will be loaded in <i>all the environments</i>, and contains the default properties that will be overwritten by any environment specified configuration.
							</dd>
							<dt>config/env/development.js</dt>
							<dd>
								This file will be loaded in a <i>development environment</i>, a property defined here will overwrite the one defined in the all.js file.
							</dd>
							<dt>config/env/production.js</dt>
							<dd>
								This file will be loaded in a <i>production environment</i>, a property defined here will overwrite the one defined in the all.js file.
							</dd>
							<dt>config/env/test.js</dt>
							<dd>
								This file will be loaded in a <i>test environment</i>, a property defined here will overwrite the one defined in the all.js file.
							</dd>
							<dt>config/env/travis.js</dt>
							<dd>
								This file will be loaded in the Travis CI testing environment, a property defined here will overwrite the one defined in the all.js file.
							</dd>
						</dl>
						<p>
							To run your application with a different environment configuration run the application like this:
							<pre>$ NODE_ENV={The Environment Name} grunt</pre>
						</p>
						<h2>Configuration Properties</h2>
						<p>
							MEAN.JS comes with a default set of configuration properties you will most likely expand with your properties. Here's the review of all the required properties used in the configuration files:
						</p>
						<dl>
							<dt>config.db</dt>
							<dd>
								This is the MongoDB connection string URI, when bootstrapped, the application will try to connect to the database using this URI, so make sure its the correct one in each environment.
							</dd>
							<dt>config.port</dt>
							<dd>
								The port used by the application, default is 3000, but as you can notice in the test.js config file, this can be changed.
							</dd>
							<dt>config.app.title</dt>
							<dd>
								This is title used as the HTML page title. Notice that it appears both in the all.js file and in all the non-production configuration files.
							</dd>
							<dt>config.app.description</dt>
							<dd>
								This is used in the HTML description META tag. Notice that it only appears in the all.js file and can be overwritten by an environment specific property.
							</dd>
							<dt>config.app.keywords</dt>
							<dd>
								This is used in the HTML keywords META tag. Notice that it only appears in the all.js file and can be overwritten by an environment specific property.
							</dd>
						</dl>
						<h2>Assets Configuration</h2>
						<p>
							One of the major issues dealing with applications development is assets management. While <b>bower</b> helps you download and update the project front-end dependencies, you would still need to include the packages JavaScript files in several places including your main application page, <b>Karma</b> configuration file and the <b>uglify</b> grunt task. Furthermore, you may want to use different assets for different environments.
						</p>
						<p>
							For this purpose we included the <b>config.assets</b> field in the environments configuration files. Using this configuration option allows you to organize all your assets inclusion in a single place. The <b>config.assets</b> field has a few properties:
						</p>
						<dl>
							<dt>config.assets.css</dt>
							<dd>
								A list of glob patterns indicating the project css files.
							</dd>
							<dt>config.assets.js</dt>
							<dd>
								A list of glob patterns idicating the project JavaScript project files.
							</dd>
							<dt>config.assets.tests</dt>
							<dd>
								A list of glob patterns idicating the project <b>Jasmine</b> test files.
							</dd>
							<dt>config.assets.lib</dt>
							<dd>
								<p>A list of glob patterns idicating the project packages files. We seperate those from other files so you could use CDN assets in your production configuration.</p>
								<dl>
									<dt>config.assets.lib.css</dt>
									<dd>
										A list of glob patterns idicating the project packages CSS files.
									</dd>
									<dt>config.assets.lib.js</dt>
									<dd>
										A list of glob patterns idicating the project packages JavaScript files.
									</dd>
								</dl>
							</dd>
						</dl>
						<p class="alert alert-info">
							<b>Note:</b> You can also include CDN paths to load packages files directly from their official CDN.
						</p>
						<h2>Social Configuration Properties</h2>
						<p>
							The application will use the <a target="_blank" href="http://passportjs.org">Passport</a> module to offer users various login options.
						</p>
						<p>
							MEAN.JS currently supports four social platforms: Facebook, Twitter, Google, and Linkedin. You can also add other platforms using a passport-provider package and duplicating the samples logic.
						</p>
						<p>
							To configure your social application oauth keys there's a property object for each platform:
						</p>
						<dl>
							<dt>config.app.{OAuth Provider}.clientID</dt>
							<dd>
								Your application oauth id.
							</dd>
							<dt>config.app.{OAuth Provider}.clientSecret</dt>
							<dd>
								Your application oauth secret.
							</dd>
							<dt>config.app.{OAuth Provider}.callbackURL</dt>
							<dd>
								Your application oauth callback URL.
							</dd>
						</dl>
						<p class="alert alert-info">
							Remember to use different configuration for each environment especially your MongoDB URI and social platform OAuth Keys.
						</p>
						<h2>Nodemailer Configuration Properties</h2>
						<p>
							The application will use the <a target="_blank" href="http://www.nodemailer.com/">Nodemailer</a> module to send email notifications.
						</p>
						<p>
							To configure nodemailer there are several properties:
						</p>
						<dl>
							<dt>config.mailer.from</dt>
							<dd>
								The sender address you want to use. (Example: John Doe &lt;johndoe@example.com&gt;)
							</dd>
							<dt>config.mailer.options.service</dt>
							<dd>
								The Email service you would like to use. (Example: gmail)
							</dd>
							<dt>config.mailer.options.auth.user</dt>
							<dd>
								The Email service username.
							</dd>
							<dt>config.mailer.options.auth.password</dt>
							<dd>
								The Email service password.
							</dd>
						</dl>
					</section>
					<div class="inner-link-anchor" id="autoload"></div>
					<section class="page-header">
						<h1>Automatically Loaded Files</h1>
					</section>
					<section>
						<p>
							Through the system we have several object automatically loaded during the application bootstrap. This was done to ease the development process and to help avoid the common mistake of not including your newly created files. The objects that are loaded automatically are:
						</p>
						<dl>
							<dt>app/models</dt>
							<dd>Mongoose models are registered automatically during the application bootstrap process. So you can just call the <i>mongoose.model('modelName')</i> whenever you need.</dd>
							<dt>app/routes</dt>
							<dd>Routing files placed in this folder will be registered automatically with the Express application. So whenever you add a new routing configuration, the new routes will be immediately available.</dd>
							<dt>config/strategies</dt>
							<dd>Passport strategies placed in this folder will automatically be loaded by the <i>config/passport.js</i> file. So whenever you add a new strategy, it will be available instantly.</dd>
							<dt>public/modules</dt>
							<dd>The new vertical modules scheme allows us to automatically include the module files in your application HTML file, this includes both <b>JavaScript</b> and <b>CSS</b> files. So have fun creating your modules, and don't worry about including your files.</dd>
						</dl>
					</section>
					<div class="inner-link-anchor" id="npm"></div>
					<section class="page-header">
						<h1>NPM</h1>
					</section>
					<section>
						<p>
							<a target="_blank" href="https://npmjs.org/">npm</a> is the Node.js package manager that uses a <a target="_blank" href="https://npmjs.org/doc/json.html">JSON file</a> to configure the backend modules your application will use, the modules will be stored in the <b>node_modules</b> folder.
						</p>
						<h2>General Dependencies</h2>
						<p>
							Here's the description of the default dependencies you'll use to bootstrap your MEAN application.
						</p>
						<dl>
							<dt>Express</dt>
							<dd>
								<a target="_blank" href="http://expressjs.com/">Express</a> is a web framework for Node.js.
							</dd>
							<dt>Express-Session</dt>
							<dd>
								<a target="_blank" href="https://github.com/expressjs/session">Express-Session</a> is the session middleware for Express 4.x applications.
							</dd>
							<dt>Body-Parser</dt>
							<dd>
								<a target="_blank" href="https://github.com/expressjs/body-parser">Body-Parser</a> is a body parsing middleware for Express 4.x applications.
							</dd>
							<dt>Cookie-Parser</dt>
							<dd>
								<a target="_blank" href="https://github.com/expressjs/cookie-parser">Cookie-Parser</a> is a cookie parsing middleware for Express 4.x applications.
							</dd>
							<dt>Compression</dt>
							<dd>
								<a target="_blank" href="https://github.com/expressjs/compression">Compression</a> is a compression middleware for Express 4.x applications.
							</dd>
							<dt>Method-Override</dt>
							<dd>
								<a target="_blank" href="https://github.com/expressjs/method-override">Method-Override</a> provides faux HTTP method support for Express 4.x applications.
							</dd>
							<dt>Morgan</dt>
							<dd>
								<a target="_blank" href="https://github.com/expressjs/morgan">Morgan</a> is the connect logger module for Express 4.x applications.
							</dd>
							<dt>Helmet</dt>
							<dd>
								<a target="_blank" href="https://github.com/evilpacket/helmet">Helmet</a> is a set of middlewares that implement various security headers for Express applications.
							</dd>
							<dt>Glob</dt>
							<dd>
								<a target="_blank" href="https://github.com/isaacs/node-glob">Glob</a> provides glob functionality for node.js applications.
							</dd>
							<dt>Consolidate</dt>
							<dd>
								<a target="_blank" href="https://github.com/visionmedia/consolidate.js/">Consolidate.js</a> is a template engine consolidation module for Node.js.
							</dd>
							<dt>Swig</dt>
							<dd>
								<a target="_blank" href="http://paularmstrong.github.io/swig/">Swig</a> is a template engine for Node.js.
							</dd>
							<dt>Mongoose</dt>
							<dd>
								<a target="_blank" href="http://mongoosejs.com/">Mongoose</a> is a Mongodb object-modeling module for Node.js.
							</dd>
							<dt>Connect-mongo</dt>
							<dd>
								<a target="_blank" href="https://github.com/kcbanner/connect-mongo">Connect-mongo</a> is a Mongodb session store module for Node.js.
							</dd>
							<dt>Connect-flash</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/connect-flash">Connect-flash</a> is a middleware used to store and retrieve messages from the session.
							</dd>
							<dt>Passport</dt>
							<dd>
								<a target="_blank" href="http://passportjs.org/">Passport</a> is an authentication middleware for Node.js that enables authentication from various OAuth sources like Facebook, Twitter, etc.
							</dd>
							<dt>Passport-Local</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-local">Passport-Local</a> is an authentication strategy for passport that enables users to authenticate using username and password.
							</dd>
							<dt>Passport-Facebook</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-facebook">Passport-Facebook</a> is an authentication strategy for passport that enables users to authenticate using their Facebook account.
							</dd>
							<dt>Passport-Twitter</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-twitter">Passport-Twitter</a> is an authentication strategy for passport that enables users to authenticate using their Twitter account.
							</dd>
							<dt>Passport-Linkedin</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-linkedin">Passport-Linkedin</a> is an authentication strategy for passport that enables users to authenticate using their Linkedin account.
							</dd>
							<dt>Passport-Google-OAuth</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-google-oauth">Passport-Google-OAuth</a> is an authentication strategy for passport that enables users to authenticate using their Google account.
							</dd>
							<dt>Lodash</dt>
							<dd>
								<a target="_blank" href="http://lodash.com/">Lodash</a> is a JavaScript utility library, for manipulating collections and objects.
							</dd>
							<dt>Forever</dt>
							<dd>
								<a target="_blank" href="https://github.com/nodejitsu/forever">Forever</a> is a Node.js module that enable node to run continuously. We use it for consistency when running on Heroku.
							</dd>
							<dt>Bower</dt>
							<dd>
								<a target="_blank" href="http://bower.io/">Bower</a> is a package manager for front-end components.
							</dd>
							<dt>Grunt</dt>
							<dd>
								<a target="_blank" href="http://gruntjs.com/">Grunt</a> is a JavaScript task runner.
							</dd>
							<dt>Grunt-CLI</dt>
							<dd>
								<a target="_blank" href="https://github.com/gruntjs/grunt-cli">Grunt-CLI</a> is Grunt's command line interface.
							</dd>
							<dt>nodemailer</dt>
							<dd>
								<a target="_blank" href="https://github.com/andris9/Nodemailer">Nodemailer</a> is an email sending module.
							</dd>
						</dl>
						<h2>Development Dependencies</h2>
						<p>
							Here's the description of the development dependencies you'll use to test and run your MEAN application.
						</p>
						<dl>
							<dt>Supertest</dt>
							<dd>
								<a target="_blank" href="https://github.com/visionmedia/supertest">Supertest</a> is a library for testing Node.js HTTP API.
							</dd>
							<dt>Should</dt>
							<dd>
								<a target="_blank" href="https://github.com/visionmedia/should.js/">Should</a> is an <a target="_blank" href="http://en.wikipedia.org/wiki/Assertion_(software_development)">assertion library</a> for BDD testing.
							</dd>
							<dt>Grunt-Node-Inspector</dt>
							<dd>
								<a target="_blank" href="https://github.com/ChrisWren/grunt-node-inspector">Grunt-Node-Inspector</a> is grunt task that that runs the <a href="https://github.com/node-inspector/node-inspector">node-inspector</a> debugging tool for Node.js applications.
							</dd>
							<dt>Grunt-Contrib-Watch</dt>
							<dd>
								<a target="_blank" href="https://github.com/gruntjs/grunt-contrib-watch">Grunt-Contrib-Watch</a> is a grunt task that runs tasks whenever watched file change.
							</dd>
							<dt>Grunt-Contrib-JSHint</dt>
							<dd>
								<a target="_blank" href="https://github.com/gruntjs/grunt-contrib-jshint">Grunt-Contrib-JSHint</a> is a grunt task that lint JavaScript files using <a target="_blank" href="http://www.jshint.com/">JSHint</a>.
							</dd>
							<dt>Grunt-Contrib-CSSLint</dt>
							<dd>
								<a target="_blank" href="https://github.com/gruntjs/grunt-contrib-csslint">Grunt-Contrib-CSSLint</a> is a grunt task that lint CSS files using <a target="_blank" href="https://github.com/CSSLint/csslint">JSHint</a>.
							</dd>
							<dt>Grunt-NGmin</dt>
							<dd>
								<a target="_blank" href="https://github.com/btford/ngmin">Grunt-NGmin</a> is a grunt task that pre-minifies AngularJS files.
							</dd>
							<dt>Grunt-Contrib-Uglify</dt>
							<dd>
								<a target="_blank" href="https://github.com/gruntjs/grunt-contrib-uglify">Grunt-Contrib-Uglify</a> is a grunt task that concat and minifies JavaScript files.
							</dd>
							<dt>Grunt-Contrib-CSSMin</dt>
							<dd>
								<a target="_blank" href="https://github.com/gruntjs/grunt-contrib-cssmin">Grunt-Contrib-CSSMin</a> is a grunt task that concat and minifies CSS files.
							</dd>
							<dt>Load-Grunt-Tasks</dt>
							<dd>
								<a target="_blank" href="https://github.com/sindresorhus/load-grunt-tasks">Load-Grunt-Tasks</a> is a grunt task that automatically loads multiple grunt tasks.
							</dd>
							<dt>Grunt-Nodemon</dt>
							<dd>
								<a target="_blank" href="https://github.com/ChrisWren/grunt-nodemon">Grunt-Nodemon</a> is a grunt task that runs <a target="_blank" href="https://github.com/remy/nodemon">nodemon</a>.
							</dd>
							<dt>Grunt-Concurrent</dt>
							<dd>
								<a target="_blank" href="https://github.com/sindresorhus/grunt-concurrent">Grunt-Concurrent</a> is a grunt task that runs tasks concurrently.
							</dd>
							<dt>Grunt-Mocha-Test</dt>
							<dd>
								<a target="_blank" href="https://github.com/pghalliday/grunt-mocha-test">Grunt-Mocha-Test</a> is a grunt task that runs server side mocha tests.
							</dd>
							<dt>Grunt-Karma</dt>
							<dd>
								<a target="_blank" href="https://github.com/karma-runner/grunt-karma">Grunt-Karma</a> is a grunt task that runs karma test runner.
							</dd>
							<dt>Karma</dt>
							<dd>
								<a target="_blank" href="http://karma-runner.github.io/0.10/index.html">Karma</a> is a test runner for JavaScript.
							</dd>
							<dt>Karma-Jasmine</dt>
							<dd>
								<a target="_blank" href="https://github.com/karma-runner/karma-jasmine">Karma-Jasmine</a> is a karma adapter for the <a target="_blank" href="http://pivotal.github.io/jasmine/">Jasmine</a> testing framework.
							</dd>
							<dt>Karma-Coverage</dt>
							<dd>
								<a target="_blank" href="https://github.com/karma-runner/karma-coverage">Karma-Coverage</a> is a karma plugin that generates code coverage using <a target="_blank" href="https://github.com/yahoo/istanbul">Istanbul</a>.
							</dd>
							<dt>Karma-Chrome-Launcher</dt>
							<dd>
								<a target="_blank" href="https://github.com/karma-runner/karma-chrome-launcher">Karma-Chrome-Launcher</a> is a karma launcher for Chrome and Chrome Canary.
							</dd>
							<dt>Karma-Firefox-Launcher</dt>
							<dd>
								<a target="_blank" href="https://github.com/karma-runner/karma-firefox-launcher">Karma-Firefox-Launcher</a> is a karma launcher for Firefox.
							</dd>
							<dt>Karma-Phantomjs-Launcher</dt>
							<dd>
								<a target="_blank" href="https://github.com/karma-runner/karma-phantomjs-launcher">Karma-Phantomjs-Launcher</a> is a karma launcher for <a target="_blank" href="http://phantomjs.org/">PhantomJS</a>.
							</dd>
						</dl>
					</section>
					<div class="inner-link-anchor" id="bower"></div>
					<section class="page-header">
						<h1>Bower</h1>
					</section>
					<section>
						<p class="alert alert-danger">
							Notice that <b>.bowerrc</b> configuration file is used to change the default install location to <b>public/lib</b>.
						</p>
						<p>
							<a target="_blank" href="https://bower.io/">Bower</a> is a front-end package manager that uses a json file to configure the components your application will use.
							<br>Here's the description of the front-end components you'll use to bootstrap your application.
						</p>
						<dl>
							<dt>Bootstrap</dt>
							<dd>
								<a target="_blank" href="http://getbootstrap.com/">Bootstrap</a> is a front-end framework containing many common web development components.
							</dd>
							<dt>AngularJS</dt>
							<dd>
								<a target="_blank" href="http://angularjs.org/">AngularJS</a> is an open-source JavaScript framework.
							</dd>
							<dt>Angular-Cookies</dt>
							<dd>
								<a target="_blank" href="http://docs.angularjs.org/api/ngCookies">Angular-Cookies</a> is convenient wrapper for cookies manipulation.
							</dd>
							<dt>Angular-Resource</dt>
							<dd>
								<a target="_blank" href="http://docs.angularjs.org/api/ngResource">Angular-Resource</a> provides interaction support with RESTful services.
							</dd>
							<dt>Angular-Animate</dt>
							<dd>
								<a target="_blank" href="http://docs.angularjs.org/api/ngAnimate">Angular-Animate</a> provides JavaScript and CSS3 animation support.
							</dd>
							<dt>Angular-Mocks</dt>
							<dd>
								<a target="_blank" href="http://docs.angularjs.org/api/ngMock">Angular-Mocks</a> provides inject and mock support to AngularJS services unit tests.
							</dd>
							<dt>Angular-Sanitize</dt>
							<dd>
								<a target="_blank" href="http://docs.angularjs.org/api/ngSanitize">Angular-Sanitize</a> provides a functionality to sanitize HTML.
							</dd>
							<dt>Angular-Bootstrap</dt>
							<dd>
								<a target="_blank" href="http://angular-ui.github.io/bootstrap/">Angular-Bootstrap</a> is a set of bootstrap components written in pure AngularJS.
							</dd>
							<dt>Angular-UI-Utils</dt>
							<dd>
								<a target="_blank" href="http://angular-ui.github.io/ui-utils/">Angular-UI-Utils</a> is a set of common utilities for AngularJS.
							</dd>
							<dt>Angular-UI-Router</dt>
							<dd>
								<a target="_blank" href="http://angular-ui.github.io/ui-router/">Angular-UI-Router</a> provides robust routing and deep linking services for AngularJS applications.
							</dd>
						</dl>
					</section>
					<div class="inner-link-anchor" id="grunt"></div>
					<section class="page-header">
						<h1>Grunt</h1>
					</section>
					<section>
						<p>
							<a target="_blank" href="http://gruntjs.com/">Grunt</a> is a great tool for automating you JavaScript tasks. The ecosystem is huge, containing many common tasks you can use in your daily development process.
						</p>
						<p>
							To configure grunt you start with the gruntfile.js file, where you define the tasks you want to run.
							<br>We start with two basic tasks:
						</p>
						<ul class="list-unstyled">
							<li>
								<h4>Default</h4>
								<p>
									The default task is the task that runs when you type 'grunt' in your command-line, the default task consists of three sub-tasks:
								</p>
								<ul>
									<li>
										<h5>JSHint</h5>
										<p>Linter task that keep your JavaScript code free of common mistakes and syntax errors.</p>
									</li>
									<li>
										<h5>CSSLint</h5>
										<p>Linter task that keep your CSS code free of common mistakes and syntax errors.</p>
									</li>
									<li>
										<h5>Watch</h5>
										<p>This watches your file system for changes and automatically reloads the application whenever you change certain files.</p>
									</li>
									<li>
										<h5>Nodemon</h5>
										<p>This runs your Node.js application using nodemon.</p>
									</li>
								</ul>
								<p>Please notice that the last two tasks are wrapped with another task called <b>Concurrent</b> to keep the application continuously running.</p>
							</li>
							<li>
								<h4>Debug</h4>
								<p>
									Same as default but will also start node-inspector for debugging.
								</p>
								<ul>
									<li>
										<h5>JSHint</h5>
										<p>Linter task that keep your JavaScript code free of common mistakes and syntax errors.</p>
									</li>
									<li>
										<h5>CSSLint</h5>
										<p>Linter task that keep your CSS code free of common mistakes and syntax errors.</p>
									</li>
									<li>
										<h5>Watch</h5>
										<p>This watches your file system for changes and automatically reloads the application whenever you change certain files.</p>
									</li>
									<li>
										<h5>Nodemon</h5>
										<p>This runs your Node.js application using nodemon.</p>
									</li>
									<li>
										<h5>Node-Inspector</h5>
										<p>This runs the <a href="https://github.com/node-inspector/node-inspector">node-inspector</a> debugging module.</p>
									</li>
								</ul>
								<p>Please notice that the last two tasks are wrapped with another task called <b>Concurrent</b> to keep the application continuously running.</p>
							</li>
							<li>
								<h4>Lint</h4>
								<p>
									This task runs when you type 'grunt lint' in your command-line, the test task consists of two sub-tasks:
								</p>
								<ul>
									<li>
										<h5>JSHint</h5>
										<p>Linter task that keep your JavaScript code free of common mistakes and syntax errors.</p>
									</li>
									<li>
										<h5>CSSLint</h5>
										<p>Linter task that keep your CSS code free of common mistakes and syntax errors.</p>
									</li>
								</ul>
							</li>
							<li>
								<h4>Build</h4>
								<p>
									This task runs when you type 'grunt build' in your command-line, the test task consists of two sub-tasks:
								</p>
								<ul>
									<li>
										<h5>JSHint</h5>
										<p>Linter task that keep your JavaScript code free of common mistakes and syntax errors.</p>
									</li>
									<li>
										<h5>CSSLint</h5>
										<p>Linter task that keep your CSS code free of common mistakes and syntax errors.</p>
									</li>
									<li>
										<h5>LoadConfig</h5>
										<p>A task that loads the environmental configuration file for the uglify and cssmin tasks.</p>
									</li>
									<li>
										<h5>NGMin</h5>
										<p>A task that pre-minifies AngularJS files.</p>
									</li>
									<li>
										<h5>Uglify</h5>
										<p>A task that concat and minifies JavaScript files.</p>
									</li>
									<li>
										<h5>CSSMin</h5>
										<p>A task that concat and minifies CSS files.</p>
									</li>
								</ul>
								<p class="alert alert-info">
									<b>Remember</b> to use the build task before deploying your application to a production environment.
								</p>
							</li>
							<li>
								<h4>Test</h4>
								<p>
									This task runs when you type 'grunt test' in your command-line, the test task consists of three sub-tasks:
								</p>
								<ul>
									<li>
										<h5>Env:test</h5>
										<p>This is a simple task that changes the NODE_ENV global environment variable to 'test'.</p>
									</li>
									<li>
										<h5>MochaTest</h5>
										<p>This runs the mocha server tests that are located in the <b>app/tests</b> folder.</p>
									</li>
									<li>
										<h5>Karma:unit</h5>
										<p>This uses the karma test runner to run the AngularJS unit tests.</p>
									</li>
								</ul>
							</li>
						</ul>
						<p class="alert alert-info">
							We recommend that you visit Grunt's <a target="_blank" href="http://gruntjs.com/getting-started">Documentation Section</a> to learn more about writing your own tasks, and mainly to <b>explore the tasks already written by the community</b>.
						</p>
					</section>
					<div class="inner-link-anchor" id="express"></div>
					<section class="page-header">
						<h1>Express &amp; Routing</h1>
					</section>
					<section>
						<p>
							<a target="_blank" href="http://expressjs.com/">Express</a> is web framework for the Node.js platform. Its robustness and minimalism made it very popular among Node.js developers.
						</p>
						<p>
							Express configuration is done in the <b>config/express.js</b> In the <b>express.js</b> file the application is initialized and configured, automatically loading the routes files in the <b>app/routes</b> folder, which contains the set of routes the application will serve.
						</p>
						<p>
							There are a few pre-bundled routes:
						</p>
						<h2>Authentication Routes</h2>
						<p>
							Authentication routes are located in the <b>app/routes/users.server.routes.js</b> file.
						</p>
						<dl>
							<dt>GET http://localhost:3000/users/me</dt>
							<dd>Returns the current authenticated user.</dd>
						</dl>
						<dl>
							<dt>POST http://localhost:3000/auth/signup</dt>
							<dd>This is used to sign up a user using username and password.</dd>
							<dt>POST http://localhost:3000/auth/signin</dt>
							<dd>This is used to sign in a user using username and password.</dd>
							<dt>GET http://localhost:3000/auth/signout</dt>
							<dd>This is used to sign out the current user.</dd>
						</dl>
						<dl>
							<dt>GET http://localhost:3000/auth/facebook</dt>
							<dd>This is used to initialize the Facebook OAuth process.</dd>
							<dt>GET http://localhost:3000/auth/facebook/callback</dt>
							<dd>This is used as the callback URI for Facebook OAuth process.</dd>
						</dl>
						<dl>
							<dt>GET http://localhost:3000/auth/twitter</dt>
							<dd>This is used to initialize the Twitter OAuth process.</dd>
							<dt>GET http://localhost:3000/auth/twitter/callback</dt>
							<dd>This is used as the callback URI for Twitter OAuth process.</dd>
						</dl>
						<dl>
							<dt>GET http://localhost:3000/auth/github</dt>
							<dd>This is used to initialize the Linkedin OAuth process.</dd>
							<dt>GET http://localhost:3000/auth/github/callback</dt>
							<dd>This is used as the callback URI for Linkedin OAuth process.</dd>
						</dl>
						<dl>
							<dt>GET http://localhost:3000/auth/google</dt>
							<dd>This is used to initialize the Google OAuth process.</dd>
							<dt>GET http://localhost:3000/auth/google/callback</dt>
							<dd>This is used as the callback URI for Google OAuth process.</dd>
						</dl>
						<p>Please notice that you can add more authentication options using a <a href="#passport">Passport Strategy</a> and this pattern.</p>
						<h2>Application Routes</h2>
						<p>
							Application core routes are located in the <b>app/routes/core.server.routes.js</b> file.
						</p>
						<dl>
							<dt>GET http://localhost:3000/</dt>
							<dd>
								The main application page. Using AngularJS helps reduce the use of server side templating, and only serve a single application page.
								<br>
								<br>To learn more about this visit the <a href="#backend-views">Backend Views</a> section.
							</dd>
						</dl>
						<h2>Example Routes</h2>
						<p>
							An 'Article' example is included with the boilerplate to help you understand how to properly build your RESTful API, the routes for this module are located in the <b>app/routes/articles.server.routes.js</b> file.
						</p>
						<dl>
							<dt>GET http://localhost:3000/articles</dt>
							<dd>
								Returns the list of articles.
							</dd>
							<dt>POST http://localhost:3000/articles</dt>
							<dd>
								Creates a new article.
							</dd>
							<dt>GET http://localhost:3000/articles/:articleId</dt>
							<dd>
								Returns an article by articleId.
							</dd>
							<dt>PUT http://localhost:3000/articles/:articleId</dt>
							<dd>
								Updates an article by ID.
							</dd>
							<dt>DEL http://localhost:3000/articles/:articleId</dt>
							<dd>
								Deletes an article by ID.
							</dd>
						</dl>
						<p class="alert alert-info">
							To learn more about Express you should visit the <a target="_blank" href="http://expressjs.com/guide.html">Guide Section</a> in the official website.
						</p>
					</section>
					<div class="inner-link-anchor" id="passport"></div>
					<section class="page-header">
						<h1>Passport</h1>
					</section>
					<section>
						<p>
							<a target="_blank" href="http://passportjs.org">Passport</a> is an authentication middleware, which allows you to implement <a target="_blank" href="http://passportjs.org/guide/providers/">many authentication methods</a> in your Express application.
						</p>
						<p>
							Passport utilizes a modular approach that uses authentication strategies modules, offering a simple, configurable authentication solutions.
						</p>
						<p>
							This boilerplate comes pre-bundled with 5 authentication mechanisms implemented in the <b>config/passport.js</b> file:
						</p>
						<dl>
							<dt>Local</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-local">The Local Strategy</a> is used to authenticate user via username and password.
							</dd>
							<dt>Facebook</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-facebook">The Facebook Strategy</a> is used to authenticate user via its Facebook account.
							</dd>
							<dt>Twitter</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-twitter">The Twitter Strategy</a> is used to authenticate user via its Twitter account.
							</dd>
							<dt>Google</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-google-oauth">The Google Strategy</a> is used to authenticate user via its Google account.
							</dd>
							<dt>Linkedin</dt>
							<dd>
								<a target="_blank" href="https://github.com/jaredhanson/passport-linkedin">The Linkedin Strategy</a> is used to authenticate user via its Linkedin account.
							</dd>
						</dl>
						<p class="alert alert-info">
							To understand Passport better we recommend that you visit the <a target="_blank" href="http://passportjs.org/guide/">Guide Section</a> in the official website.
						</p>
					</section>
					<div class="inner-link-anchor" id="backend-views"></div>
					<section class="page-header">
						<h1>Backend Views</h1>
					</section>
					<section>
						<p>
							AngularJS reduces the need for server side templating. What once was a web application served by server as HTML pages can now be implemented using Angular's template system.
						</p>
						<h4>So why do you still keep a views folder in your <b>app</b> folder?</h4>
						<p>
							There are few answers to this question:
						</p>
						<ol>
							<li>
								You still need to render the index and error page.
							</li>
							<li>
								You might need to render HTML templates for your email notifications.
							</li>
							<li>
								You want to render local configuration properties in the template. For instance, the title property from the configuration file can be used in the title element of the HTML page.
							</li>
							<li>
								<a href="#angularjs-modules">AngularJS module system</a> is implemented in a way that allows you to automatically load the modules .js files in template.
							</li>
						</ol>
						<p>
							So we can't use static templates, and we have to use some kind of template engine, but which one?
						</p>
						<h2>Swig Template Engine</h2>
						<p>
							<a target="_blank" href="http://paularmstrong.github.io/swig/">Swig</a> is a template engine, written by <a target="_blank" href="https://github.com/paularmstrong">Paul Armstrong</a>.
						</p>
						<p>
							While <a target="_blank" href="http://jade-lang.com/">JADE</a> is the default template engine used by Express, and is by far the most popular template engine, it doesn't suit this boilerplate for several reasons:
						</p>
						<ol>
							<li>It's slower.</li>
							<li>It uses its own language, steeping the learning curve.</li>
							<li>You don't need it! JADE's greatest advantage is to facilitate the task of writing a lot of HTML that is being served by the server. You're going to use AngularJS client templating engine, thus relieving the need for server templating.</li>
						</ol>
						<p>
							On the other hand, using Swig has a few advantages:
						</p>
						<ol>
							<li>It's faster, as in <a href="http://paularmstrong.github.io/node-templates/benchmarks.html">way faster</a>.</li>
							<li>It uses HTML.</li>
							<li>It has all the features we need to render our index and error pages!</li>
						</ol>
						<p>
							To summarize, when coding a Node.js website, you might want to use other template engines, but approaching web application development using AngularJS, we think Swig is the best choice.
						</p>
						<p class="alert alert-info">
							To understand Swig better we recommend that you visit the <a target="_blank" href="http://paularmstrong.github.io/swig/">Official Website</a>.
						</p>
						<h2>The Views</h2>
						<p>
							There are 4 files in the views folder:
						</p>
						<dl>
							<dt>Layout</dt>
							<dd>
								This is most important file, which sets the layout used to render all the other templates.
							</dd>
							<dt>Index</dt>
							<dd>
								The index template is served as the main application page.
							</dd>
							<dt>404</dt>
							<dd>
								The 404 error template is served whenever express cant find a routing scheme for the current path.
							</dd>
							<dt>500</dt>
							<dd>
								The 500 error template is served whenever there's a server error.
							</dd>
						</dl>
						<h2>The Templates</h2>
						<p>
							The templates folder is placed inside the views folder and currently contains 2 files:
						</p>
						<dl>
							<dt>Reset Password Email</dt>
							<dd>
								An email template sent to users after they've request to reset their password.
							</dd>
							<dt>Reset Password Confirmation Email</dt>
							<dd>
								An email template sent to users after they've reset their password.
							</dd>
						</dl>
					</section>
					<div class="inner-link-anchor" id="server-tests"></div>
					<section class="page-header">
						<h1>Server Tests</h1>
					</section>
					<section>
						<p>
							We use <a target="_blank" href="http://visionmedia.github.io/mocha/">Mocha</a> to test the server side logic. Mocha tests are asynchronous, easy to maintain, and uses a readable <a target="_blank" href="http://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> syntax.
						</p>
						<h4>Assertions</h4>
						<p>
							Mocha needs an external assertion library to predicate the result of each test, in this case <a target="_blank" href="https://github.com/visionmedia/should.js">Should.js</a> is being used. Should is an expressive library aiming to simplify tests and be readable. It extends the Object.prototype with a single non-enumerable getter that allows you to express how that object should behave.
						</p>
						<h4>Test Files</h4>
						<p>
							Each entity have its own test file located inside the <b>app/tests</b> folder.
						</p>
						<h4>Writing Tests</h4>
						<p>
							There are a few common steps we use to test an entity:
						</p>
						<ol>
							<li>
								In the <b>beforeEach</b> or <b>before</b> functions take care of prerequisites and create the objects you are about to use in your tests.
							</li>
							<li>
								For each test start with a <b>describe</b> function to indicate which method is being tested.
							</li>
							<li>
								Next, add your scenario tests using the <b>it</b> function.
							</li>
							<li>
								In the <b>it</b> function run the tests functionality and use should to assert what the end result should be.
							</li>
							<li>
								Finally use <b>after</b> or <b>afterEach</b> functions to finalize your tests and clear the test database.
							</li>
						</ol>
						<p class="alert alert-info">
							To learn more about how to write your tests visit <a href="#article-example">The Article Example Section</a>.
						</p>
					</section>
					<div class="inner-link-anchor" id="angularjs-tests"></div>
					<section class="page-header">
						<h1>AngularJS Tests</h1>
					</section>
					<section>
						<p>
							Testing is an important feature of the AngularJS framework. It is so well established that the team has create a very cool to automate tests, the <a target="_blank" href="http://karma-runner.github.io/0.10/index.html">Karma Test Runner</a>.
						</p>
						<p>
							The Karma Test Runner is a unique testing tool that enables you to automatically test your code on multiple real browsers using Node.js and Socket.io.
						</p>
						<p>
							Karma is not a testing library, it utilizes other testing frameworks to test your code and comes with different framework adapters, supporting the common testing frameworks.
						</p>
						<p>
							In the AngularJS documentation the team uses <a target="_blank" href="http://pivotal.github.io/jasmine/">Jasmine Testing Framework</a> to unit test the application. So, in the boilerplate we use Jasmine as well.
						</p>
						<p>
							Now AngularJS supports two kind of tests:
						</p>
						<dl>
							<dt>E2E</dt>
							<dd>
								End-To-End testing enables to test several parts of the application together, so instead of just testing your controller's methods, you can actually test different scenarios in your application. To understand it better visit the <a target="_blank" href="http://docs.angularjs.org/guide/dev_guide.e2e-testing">AngularJS E2E Testing Section</a>.
							</dd>
							<dt>Unit</dt>
							<dd>
								Unit testing is the more common testing method, which enables you to test different units of the application, it's a more detailed kind of testing, which neglects the bigger picture and focuses on the single unit functionality. To understand it better visit the <a target="_blank" href="http://docs.angularjs.org/guide/dev_guide.unit-testing">AngularJS Unit Testing Section</a>.
							</dd>
						</dl>
						<p class="alert alert-info">
							In the example provided there are only unit tests, E2E should come out in the next version.
						</p>
						<h2>Karma Configuration</h2>
						<p>
							Karma configuration file, <b>karma.conf.js</b>, is the located at the root folder. You can learn more about the different configuration properties in the <a target="_blank" href="http://karma-runner.github.io/0.8/config/configuration-file.html">Configuration Section</a> on the official website.
							<br>But here is a quick review of the properties used in the boilerplate:
						</p>
						<dl>
							<dt>Frameworks</dt>
							<dd>The testing framework you want to karma to use, in this case we'll use Jasmine.</dd>
							<dt>Files</dt>
							<dd>
								This is really important! This is the list of files that karma should load before starting the tests.
								<p class="alert alert-info">
									Notice that we load the angular module tests automatically, so whenever you add a new module, Karma will run your tests without you having to change anything at all.
								</p>
							</dd>
							<dt>LogLevel</dt>
							<dd>Determines the logging level of karma console output.</dd>
							<dt>Browsers</dt>
							<dd>Determines which browsers to launch when testing, the boilerplate comes pre-bundled with 3 launchers: Chrome, Firefox, and PhantomJS.</dd>
							<dt>SingleRun</dt>
							<dd>Determines if karma will run one time and return the results, or stay connected to watch for changes.</dd>
						</dl>
						<p>
							Notice that karma is executed as a grunt task that looks for the configuration file.
						</p>
						<h2>Unit Testing</h2>
						<p>
							In the Article examples attached, there's a unit test example in the <b>tests/article.spec.js</b> file. Notice that we use <a target="_blank" href="http://docs.angularjs.org/api/ngMock">angular-mocks</a> to simulate the HTTP requests. The tests are defined to cover all the CRUD operations, and will test the $resource service as well.
						</p>

						<p>
							There are a few common steps we use to unit test the application:
						</p>
						<ol>
							<li>
								In the <b>beforeEach</b> function take care of prerequisites and create the objects you are about to use in your tests.
							</li>
							<li>
								For each test start with a <b>describe</b> function to indicate which method is being tested.
							</li>
							<li>
								Next, add your scenario tests using the <b>it</b> function.
							</li>
							<li>
								In the <b>it</b> function run the tests functionality.
							</li>
							<li>
								Finally use <a target="_blank" href="https://github.com/pivotal/jasmine/wiki/Matchers">Jasmine matchers</a> to test the result.
							</li>
						</ol>
						<p class="alert alert-info">
							To learn more about how to write your tests visit <a href="#article-example">The Article Example Section</a>.
						</p>
					</section>
					<div class="inner-link-anchor" id="angularjs-modules"></div>
					<section class="page-header">
						<h1>AngularJS Modules</h1>
					</section>
					<section>
						<p>
							When we started with MEAN one of our major concerns was how to structure our AngularJS application, and on the first few AngularJS applications, we used the great <a href="https://github.com/angular/angular-seed">AngularJS Seed Project</a> provided by the AngularJS team.
							<br>The basic structure for this project is quite simple:
						</p>
						<pre>
|-css
|---app.css
|-img
|-js
|---app.js
|---controllers.js
|---directives.js
|---filters.js
|---services.js
|-partials
|---partial1.html
|---partial2.html
index.html
</pre>
						<p>
							Notice that in the JS folder there are a few pre-bundled files. Basically you just place all your controllers in the controllers.js file, all your services in the services.js file, and so on. This is nice for a single developer working on a small project, but when working on production web application, pretty soon you get bloated JS files, which create real issues when trying to work in a team.
						</p>
						<p>
							Then we changed the structure a bit to look something like this:
						</p>
						<pre>
|-css 
|---app.css 
|-img 
|-js 
|---app.js
|---controllers
|-----controller1.js
|-----controller2.js
|---directives
|-----directive1.js
|----- directive2.js
|---filters
|-----filter1.js
|-----filter2.js
|---services
|-----service1.js
|-----service2.js
|-partials
|---partial1.html
|---partial2.html
index.html
</pre>
						<p>
							Reorganizing the project this way helped us create bigger projects that are more maintainable in the long term. For a while we had fun using this but lately we found out that wasnt enough. Now instead of bloating a single JavaScript file, we had pretty big folders containing ~20 controllers, and even more views in the partials folder.
						</p>
						<p>
							Luckily, when the original MEAN.IO boilerplate gained some traction, we got a chance to talk to some great AngularJS developers writing blogs and working on some popular libraries. One of the greatest topics in our conversations was Angulars modularity.
						</p>
						<h4>AngularJS Module System</h4>
						<p>
							AngularJS module system is a core feature when developing AngularJS applications; actually every AngularJS application is basically an AngularJS module. The other thing about AngularJS modules is that when defining a module you can also include sub-modules as dependencies. It usually looks something like this:
						</p>
						<pre>
angular.module(FirstDependency, []);
angular.module(SecondDependency, []); 
angular.module(MainModule, [FirstDependency, SecondDependency]);
</pre>
						<p>
							In this example we define the first and second modules and then we define the main module with the two sub-modules as dependencies. Later when you want to define an AngularJS entity you can simply use the sub modules as way to separate your application logic. For example defining a controller will look something like this:
						</p>
						<pre>
angular.module(FirstDependency).controller();
</pre>
						<h4>AngularJS Horizontal Modules</h4>
						<p>
							In their seed project, the AngularJS team recommends using modules in a horizontal way that ends up looking like this:
						</p>

						<pre>
angular.module(application.controllers, []);
angular.module(application.services, []);
angular.module(application, [application.controllers, application.services]);
</pre>

						<p>
							With this approach you arrange your AngularJS entities in horizontal modules that represents their role:
						</p>
						<table class="table table-bordered text-center">
							<tr>
								<th class="text-center" colspan="4">Application</th>
							</tr>
							<tr>
								<th class="text-center">Controllers</th>
								<th class="text-center">Directives</th>
								<th class="text-center">Filters</th>
								<th class="text-center">Services</th>
							</tr>
							<tr>
								<td>Controller1</td>
								<td>Directive1</td>
								<td>Filter1</td>
								<td>Service1</td>
							</tr>
							<tr>
								<td>Controller2</td>
								<td>Directive2</td>
								<td>Filter2</td>
								<td>Service2</td>
							</tr>
							<tr>
								<td>Controller3</td>
								<td>Directive3</td>
								<td>Filter3</td>
								<td>Service3</td>
							</tr>
						</table>
						<p>
							Although this helps create fewer modules those modules wont represent the higher functionality of each entity, for example all the controllers are defined under the same module regardless of their actual purpose. While this is suitable for small projects, using horizontal modules doesn't scale well for bigger projects.
						</p>

						<h4>Vertical Modules Are Better</h4>
						<p>
							During our conversation with some of the main contributors to the popular <a target="_blank" href="http://angular-ui.github.io">Angular-UI</a>, they pointed this issue to us. When we observed our AngularJS applications we discovered it would be better to restructure our applications in a vertical manner:
						</p>
						<table class="table table-bordered text-center">
							<tr>
								<th class="text-center" colspan="3">Application</th>
							</tr>
							<tr>
								<th class="text-center">Core Module</th>
								<th class="text-center">Users Module</th>
								<th class="text-center">Articles Module</th>
							</tr>
							<tr>
								<td>CoreController1</td>
								<td>UsersController1</td>
								<td>ArticlesController1</td>
							</tr>
							<tr>
								<td>CoreController2</td>
								<td>UsersController1</td>
								<td>ArticlesController2</td>
							</tr>
							<tr>
								<td>CoreService1</td>
								<td>UsersService1</td>
								<td>ArticlesService1</td>
							</tr>
							<tr>
								<td>CoreFilter1</td>
								<td>UsersFilter1</td>
								<td>ArticlesFilter1</td>
							</tr>
							<tr>
								<td>CoreDirective1</td>
								<td>UsersDirective1</td>
								<td>ArticlesDirective2</td>
							</tr>
						</table>

						<p>
							This helped us divide the project logic into modules that represent individual logical units, and it didn't surprised us to find out the Angular-UI projects uses the same approach.
						</p>

						<h4>New Folder Structure</h4>
						<p>
							Using vertical modules only solves half the problem because we still use horizontal approach in our folder structure. This means that all your application controllers will reside in the same folder, as are all the services, directives, filters, and views. In this case you wouldnt be able to associate a file with its module until you open it.
						</p>
						<p>
							So we converted our application structure to a vertical structure to fit the vertical modular approach:
						</p>
						<pre>						
|-css 
|-img 
|-js 
|-modules 
|---articles 
|-----config 
|-----controllers 
|-----services 
|-----tests 
|-----views
|---core
|-----config
|-----controllers
|-----tests
|-----views
|---users
|-----config
|-----controllers
|-----services
|-----views
</pre>
						<p>
							In this case we have 3 modules:
						</p>
						<dl>
							<dt>Core</dt>
							<dd>Containing the application core configuration, controllers, test, and views.</dd>
							<dt>Users</dt>
							<dd>Containing the application authentication configuration, controllers, services, and views.</dd>
							<dt>Articles</dt>
							<dd>The example module we added, that contains article related configuration, routing, controllers, services, tests, and views.</dd>
						</dl>
						<p>
							This structure allow clear separation of functionality and concerns, so just by looking at the folder structure you can start asking questions about your modules, for example why does the users module have no tests? (hint: Its our fault and we plan to add those :)).
						</p>
						<p>
							But we didnt want to stop at this point!
						</p>
						<p>
							Because we are building a full-stack solution, wont it be great if module files could be automatically included in the backend view HTML, eliminating common import mistakes? We do two things to help with this issue:
						</p>
						<ol>
							<li>
								In the <b>config/express.js</b> file, we iterate over the modules folder to automatically add the .JS and .CSS files to the layout HTML.
							</li>
							<li>
								<p>
									There two kind of modules you'll add to your application: third-party modules and custom modules.
								</p>
								<p>
									To add third-party modules use the <b>public/config.js</b> file where we added an array property called <b>applicationModuleVendorDependencies</b>. When you add a new third-party module you should add it to this array so the main module can load it as a depenedency.
								</p>
								<p>
									To register your own module, we created the <b>ApplicationConfiguration.registerModule</b> method. To add your custom module and your module and it will automatically be loaded as a dependency to the AngularJS main application module.
								</p>
							</li>
						</ol>
						<p>
							This method has a few advantages:
						</p>
						<ol>
							<li>
								Team members have a method of organizing their code, so every module will look the same.
							</li>
							<li>
								Everyone has a clearer and broader view of the project.
							</li>
							<li>
								Working together becomes faster, especially in merging the different development branches.
							</li>
							<li>
								Because this is very structured you can start automating some common tasks, like creating a new module, verifying an existing module, etc.(Hmmm... Future Generator)
							</li>
							<li>
								You can avoid common mistakes by not including all the JS files, or forget to add your module as a dependency to the main module.
							</li>
							<li>
								Reusage of modules is now easier because you can just seamlessly copy your module folder to another project.
							</li>
							<li>
								Third party modules can now be easily shared and implemented.
							</li>
						</ol>
						<h4>ApplicationConfiguration</h4>
						<p>
							While the angular module system is quite robust it lacks a few options, mainly the abiliy to add dependencies to the main module after it was already created. Because of that we use the <b>ApplicationConfiguration</b> object to maintain a list of modules, which the main module will use as depenedencies. If it weren't for the <b>ApplicationConfiguration</b>, you would have to register your module in two place:
						</p>
						<ol>
							<li>
								When you create your module using the
								<code>angular.module(...)</code>method.
							</li>
							<li>
								When you create your main application module you'll have to register your module as a dependency in the dependencies list.
							</li>
						</ol>
						<p>
							This can become an annoying pitfull, so we added the <b>ApplicationConfiguration</b> that is loaded before all the modules file. The <b>ApplicationConfiguration</b> global object expose a method named <b>registerModule</b>, this method will create the new angular module and add it to list of dependencies of the main application module.
						</p>
						<p>
							We recommend that you take a look at the code that is placed inside the <b>/public/config.js</b> file.
						</p>
						<h4>Module Structure</h4>
						<p>
							So how should you add a new module?
						</p>
						<p>

							To add a new module, youll have to create a new folder in the <b>public/modules</b> folder. The directory structure should look something like this:
						</p>
						<pre>
|-module 
|---config 
|---controllers 
|---css 
|---directives 
|---filters 
|---img 
|---services 
|---tests 
|---views 
|---module.js
</pre>
						<p>
							In each folder you'll include the appropriate module entities, you can also delete the empty folders to keep it clean.
						</p>
						<p>
							Finally you have to add your module.js file, which should look something like this:
						</p>
						<pre>
'use strict';

// Use Applicaion configuration module to register a new module
ApplicationConfiguration.registerModule('moduleName');
</pre>

						<p>
							Thats it! This way the <b>registerModule</b> method will create your module and push it to the dependencies list of your AngularJS main application module.
							<br>MEAN will take care of everything else, like including those files in the layout HTML and bootstrap the AngularJS application using your module as a dependency.
						</p>
						<h4>Module Tests</h4>
						<p>
							Adding Karma tests is a simple task, and you can follow the <a href="#article-example">Article Example</a> to learn all about it.
						</p>
						<p>
							But here is another neat feature: loading your module tests is also done automatically! Karam config file will iterate through the module folder and add your new module tests as well. Don't worry! if you haven't written any tests karma will skip your module and just run the tests you already have.
						</p>
						<p class="alert alert-danger">
							<b>Notice:</b> Your test files should be placed in the <b>module/tests</b> folder or else MEAN won't ignore them and add them in the HTML as script files.
						</p>
					</section>
					<div class="inner-link-anchor" id="menus"></div>
					<section class="page-header">
						<h1>AngularJS Menus Service</h1>
					</section>
					<section>
						<p>
							In the 0.3.x version, MEAN.JS has introduced a new AngularJS service that helps you manage your application menus. The menu service has several methods:
						</p>
						<dl>
							<dt>Menus.getMenu(menuId)</dt>
							<dd>
								Returns a menu object identified by the menuId argument.
							</dd>
							<dt>Menus.addMenu(menuId, [isPublic], [roles])</dt>
							<dd>
								Creates a new menu object, which will be identified by the menuId argument. This method also include three arguments:
								<ol>
									<li>
										<b>menuId</b> (Required) - Indicates the menu identifier for future reference.
									</li>
									<li>
										<b>isPublic</b> (Optional; Default: false) - Indicates whether a menu should be displayed only to authenticated users.
									</li>
									<li>
										<b>roles</b> (Default: ['user']) - An array indicating the roles that are allowed to view this menu.
									</li>
								</ol>
							</dd>
							<dt>Menus.addMenuItem(menuId, menuItemTitle, menuItemURL, [menuItemUIRoute], [isPublic], [roles]);</dt>
							<dd>
								Creates a new menu item object. This method also include couple of arguments:
								<ol>
									<li>
										<b>menuId</b> (Required) - Indicates the menu identifier.
									</li>
									<li>
										<b>menuItemTitle</b> (Required) - A String title for the menu item.
									</li>
									<li>
										<b>menuItemURL</b> (Required) - The path this menu item will link to.
									</li>
									<li>
										<b>menuItemUIRoute</b> (Optional; Default: menuItemURL) - The UIRoute value, which is used to define the URL scheme where this menu item is marked as active.
									</li>
									<li>
										<b>isPublic</b> (Optional; Default: menu.isPublic) - Indicates whether a menu item should be displayed only to authenticated users.
									</li>
									<li>
										<b>roles</b> (Optional; Default: ['user']) - An array indicating the roles that are allowed to view this menu item.
									</li>
								</ol>
							</dd>
							<dt>Menus.addSubMenuItem(menuId, rootMenuItemURL, menuItemTitle, menuItemURL, [menuItemUIRoute], [isPublic], [roles]);</dt>
							<dd>
								Adds a submenu item to an existing item object. This method also include couple of arguments:
								<ol>
									<li>
										<b>menuId</b> (Required) - Indicates the menu identifier.
									</li>
									<li>
										<b>rootMenuItemURL</b> (Required) - Indicates the root menu item identifier.
									</li>
									<li>
										<b>menuItemTitle</b> (Required) - A String title for the menu item.
									</li>
									<li>
										<b>menuItemURL</b> (Required) - The path this menu item will link to.
									</li>
									<li>
										<b>menuItemUIRoute</b> (Optional; Default: menuItemURL) - The UIRoute value, which is used to define the URL scheme where this menu item is marked as active.
									</li>
									<li>
										<b>isPublic</b> (Optional; Default: menu.isPublic) - Indicates whether a menu item should be displayed only to authenticated users.
									</li>
									<li>
										<b>roles</b> (Optional; Default: ['user']) - An array indicating the roles that are allowed to view this menu item.
									</li>
								</ol>
							</dd>
						</dl>
						<p>
							Using the Menus service is usually done in a configuration sections of your application modules. A simple configuration would look like this:
						</p>
						<pre>angular.module('example').run(['Menus',
	function(Menus) {
		// Set top bar menu items
		Menus.addMenuItem('topbar', 'Example', 'example');
	}
]);</pre>
						<p class="alert alert-info">
							To learn more about the Menus service, visit <a href="#article-example">The Article Example Section</a>.
						</p>
					</section>
					<div class="inner-link-anchor" id="article-example"></div>
					<section class="page-header">
						<h1>The Article Example</h1>
					</section>
					<section>
						<p>
							The Article example is an end-to-end example that includes the basic CRUD operations, which are most commonly used in content websites. It is divided into two parts: The Express backend module, and The AngularJS front-end module.
						</p>
						<h2>Express Backend Module</h2>
						<p>
							We mostly use the Express application as a RESTful API for the AngularJS application. This means the common <a target="_blank" href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC architecture</a> can be reduced to an MC architecture, where the Model represent the data entities in the system, while the Controller is in charge of the business logic, leaving the View part only in the AngularJS application.
						</p>
						<h4>Mongoose Model</h4>
						<p>
							<a target="_blank" href="http://mongoosejs.com/">Mongoose</a> is a Node.js schema-based object-modeling module. Mongoose models are defined using a Schema object that allows you to model and validate your data.
							<h5>The Mongoose Schema</h5>
							<p>The Mongoose schema is used to define the structure of your application's data. Entries are called Documents in the MongoDB context, and schemas describe what types of properties they have, and what references and relations exist between them.</p>
							<p>In our article example, we define the type of each property, as well as a possible default value. When necessary, we can also use properties like "trim" to make sure our data is properly transformed before it is saved.</p>
							<h5>Using Validations and Middleware</h5>
							<p>We can make sure the data we save complies with specific validation tests, and reject entries, which do not comply. In our example, we validate the title returns a true result for "title.length", to ensure it isn't blank. Similarly, we could run any function on the data being saved, and enforce whatever policy we want.</p>
							<p><b>Middleware</b> is used whenever we want to execute code before or after we run any kind of operation on an entry. This gives us the opportunity to carry out validation, authorization, monitoring and other operations, before (or after) the entry is operated upon.</p>
							<h5>How statics are defined</h5>
							<p>We can extended the methods we build into the schema. In our example, we added a "load" method to the article schema, which allows us to automatically load an article, and populate a reference to the document describing the article's author.</p>
						</p>
						<p class="alert alert-info">
							To learn more about Mongoose you should visit the <a target="_blank" href="http://mongoosejs.com/">Official Website</a>.
						</p>
						<h4>Express Controller</h4>
						<p>
							In MEAN, the controllers are where you'd query your database, and preform any server-side calculations before relying the data to the client. In the example articles controller example we define the basic CRUD operations and other required methods:
						</p>
						<dl>
							<dt>create</dt>
							<dd>The create method creates a new Article document.
								<dt>read</dt>
								<dd>The read method returns a single article.</dd>
								<dt>update</dt>
								<dd>The update method updates a single article.</dd>
								<dt>delete</dt>
								<dd>The delete method removes a single article.</dd>
								<dt>list</dt>
								<dd>The list method returns a list of articles.</dd>
								<dt>articleByID</dt>
								<dd>The articleByID method sets the current article object by its ID.</dd>
								<dt>hasAuthorization</dt>
								<dd>The hasAuthorization method checks if the current user created the current article.</dd>
						</dl>
						<h4>Express Routes</h4>
						<p>
							In order to expose the controller methods as REST endpoints, we assign the controller methods to Express endpoints. This is done in the <b>app/routes/articles.js</b> file. Here we also hook up the middleware used to make sure a request for updating or removing the article is only allowed by an authorized user.
						</p>
						<p>
							Here are the routes we defined for the article example:
						</p>
						<dl>
							<dt>GET http://localhost:3000/articles</dt>
							<dd>
								Returns the list of articles.
							</dd>
							<dt>POST http://localhost:3000/articles</dt>
							<dd>
								Creates a new article.
							</dd>
							<dt>GET http://localhost:3000/articles/:articleId</dt>
							<dd>
								Returns an article by articleId.
							</dd>
							<dt>PUT http://localhost:3000/articles/:articleId</dt>
							<dd>
								Updates an article by ID.
							</dd>
							<dt>DEL http://localhost:3000/articles/:articleId</dt>
							<dd>
								Deletes an article by ID.
							</dd>
						</dl>
						<h4>Express Mocha Tests</h4>
						<p>
							We use <a target="_blank" href="http://visionmedia.github.io/mocha/">Mocha</a> tests to verify our model. In this case the we added a test example that cover the article save method. The test is self is broken into three parts:
						</p>
						<ul class="list-unstyled">
							<li>
								<h5>Before Testing</h5>
								<p>
									Before we test the article save method, we'll create the user object, then save it, and in the callback create a new article object.
								</p>
							</li>
							<li>
								<h5>The Tests</h5>
								<p>
									Now we're ready to perform our tests. In the first test we'll try to save the article, then use the <a target="_blank" href="https://github.com/visionmedia/should.js">should assertion library</a> to verify it was saved without an error.
								</p>
								<p>
									In the second test, we'll check the article model validation. We'll set the title property to an invalid value, then try to the save the document, we'll use should again to verify that an error has occurred.
								</p>
							</li>
							<li>
								<h5>After The Test</h5>
								<p>
									Once our testing is over, we can now do cleanup and remove the documents from our test database.
								</p>
							</li>
						</ul>

						<p class="alert alert-info">
							To understand BDD better please visit the <a target="_blank" href="http://visionmedia.github.io/mocha/">Official Mocha Website</a>.
						</p>
						<h2>AngularJS Front-End Module</h2>
						<h4>Folder Structure</h4>
						<p>
							Each AngularJS module is organized in an isolated folder containing the logical structure of the module functionality. In the Article example case, that folder is located at <b>public/modules/articles</b>. This is the folder structure of the Article module:
						</p>
						<dl>
							<dt>config</dt>
							<dd>
								The config folder contains any AngularJS configuration related to the articles module, for instance this folder contains the routes.js file, which defines the AngularJS routing for the articles module.
							</dd>
							<dt>controllers</dt>
							<dd>
								The controllers folder contains any AngularJS controllers related to the articles module.
							</dd>
							<dt>services</dt>
							<dd>
								The services folder contains any AngularJS services related to the articles module.
							</dd>
							<dt>tests</dt>
							<dd>
								The tests folder contains any Jasmine tests related to the articles module.
							</dd>
							<dt>views</dt>
							<dd>
								The views folder contains any AngularJS partial views related to the articles module.
							</dd>
						</dl>
						<p class="alert alert-warning">
							The module folder structure is dynamic and may contain any components related to that module. While the article example is simple, modules can become much more complex, and may contain several services, controller, directives, etc.
						</p>
						<h4>AngularJS Service</h4>
						<p>
							The client-side of the article entities is connected to the Express route through an AngularJS Service. In this case, we use <a target="_blank" href="http://docs.angularjs.org/api/ngResource">ngResource</a> to easily connect our RESTful endpoints to Express.
						</p>
						<p class="alert alert-warning">
							The <a target="_blank" href="http://docs.angularjs.org/api/ngResource.$resource">$resource</a> service supports RESTful CRUD endpoints out of the box, <b>except for the update method which requires specifically defining it to use the PUT verb</b>.
						</p>

						<h4>AngularJS Controller</h4>
						<p>
							The AngularJS controller is where you'll write your logic, in this case the controller is simply corresponding to the RESTful service CRUD operations:
						</p>
						<dl>
							<dt>create</dt>
							<dd>The create method is used to create new articles.</dd>
							<dt>remove</dt>
							<dd>The remove method is used to delete an article.</dd>
							<dt>update</dt>
							<dd>The update method is used to update an article.</dd>
							<dt>findOne</dt>
							<dd>The findOne method is used to fetch a single article.</dd>
							<dt>find</dt>
							<dd>The find method is used to fetch a list of articles.</dd>
						</dl>
						<h4>AngularJS Views</h4>
						<p>
							The AngularJS views render the data passed through the controller, in this case each view is a visual representation of a CRUD operation:
						</p>
						<dl>
							<dt>create-article.client.view.html</dt>
							<dd>The create.html view is used to create an article.</dd>
							<dt>view-article.client.view.html</dt>
							<dd>The view.html view is used to present a single article.</dd>
							<dt>edit-article.client.view.html</dt>
							<dd>The edit view is used to update an article.</dd>
							<dt>list-articles.client.view.html</dt>
							<dd>The list view is used to view a list of articles.</dd>
						</dl>
						<h4>AngularJS Routes</h4>
						<p>
							AngularJS use the <a target="_blank" href="http://angular-ui.github.io/ui-router/">UI-Router</a> module to define the various routes of the module. Each route is defined using the <b>$stateProvider</b> service, and defines a path to the template, which will be rendered when navigating to a specific URL.
						</p>
						<p>
							In this example we configured 4 routes:
						</p>
						<dl>
							<dt>/#!/articles</dt>
							<dd>When navigating to this URL, UI-Router will render the <b>list-articles.client.view.html</b> view.</dd>
							<dt>/#!/articles/create</dt>
							<dd>When navigating to this URL, UI-Router will render the <b>create-article.client.view.html</b> view.</dd>
							<dt>/#!/articles/:articleId</dt>
							<dd>When navigating to this URL, UI-Router will render the <b>view-article.client.view.html</b> view.</dd>
							<dt>/#!/articles/:articleId/edit</dt>
							<dd>When navigating to this URL, UI-Router will render the <b>edit-article.client.view.html</b> view.</dd>
						</dl>
						<p class="alert alert-info">
							Notice that we define a routing parameter called articleId, to grab it later in the controller and fetch the correct article.
						</p>

						<h4>AngularJS Menu Items</h4>
						<p>
							Your stack is bundled with an <a href="#menus">AngularJS Menus Service</a> that enables to add menu items directly from the module configuration file. In the article example you can see how the two menu items are added to the top bar menu in the <b>articles.client.config.js</b> file:
							<pre>angular.module('articles').run(['Menus',
	function(Menus) {
		// Set top bar menu items
		Menus.addMenuItem('topbar', 'Articles', 'articles', 'dropdown', '/articles(/create)?');
		Menus.addSubMenuItem('topbar', 'articles', 'List Articles', 'articles');
		Menus.addSubMenuItem('topbar', 'articles', 'New Article', 'articles/create');
	}
]);</pre>
						</p>

						<h4>AngularJS Unit Tests</h4>
						<p>
							AngularJS Jasmine tests are a bit trickier, but are mostly done in the same way as Mocha.
						</p>
						<ul class="list-unstyled">
							<li>
								<h5>Before Testing</h5>
								<p>
									Before testing the article controller, there a few prerequisites we need to take care of:
								</p>
								<ul>
									<li>Initialize the global variables.</li>
									<li>Add a Jasmine Matcher that <b>compares objects while ignoring the object methods</b>.</li>
									<li>Load the main application module.</li>
									<li>
										Use the inject function to:
										<ol>
											<li>
												Point the global variables to the AngularJS services we are about to use.
											</li>
											<li>
												Create a new ArticleController instance.
											</li>
										</ol>
									</li>
								</ul>
							</li>
							<li>
								<h5>The Test</h5>
								<p>
									Most of your tests will look quite the same and will include similar steps:
								</p>
								<ul>
									<li>
										First you'll have to create your sample data.
									</li>
									<li>
										Then, use <a target="_blank" href="http://docs.angularjs.org/api/ngMock">Angular-Mocks</a> to set the <b>httpBackend</b> expected response.
									</li>
									<li>
										Call the controller method you would like to test.
									</li>
									<li>
										Then, use <b>httpBackend.flush()</b> to emulate server response.
									</li>
									<li>
										Finally, use a Jasmine matcher to verify the test result.
									</li>
								</ul>
							</li>
						</ul>
						<p class="alert alert-info">
							To understand AngularJS unit testing better, please visit the <a target="_blank" href="http://docs.angularjs.org/guide/dev_guide.unit-testing">Unit Testing Section</a> in the official website.
						</p>
					</section>
				</section>
			</section>
		</section>
	</section>
	<footer class="container text-center small">
		Licensed under MIT. Documentation licensed under CC BY 3.0. Copyright 2014.
	</footer>

	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>

	<!-- Google Analytics-->
	<script>
	(function(i, s, o, g, r, a, m) {
		i['GoogleAnalyticsObject'] = r;
		i[r] = i[r] || function() {
			(i[r].q = i[r].q || []).push(arguments)
		}, i[r].l = 1 * new Date();
		a = s.createElement(o),
		m = s.getElementsByTagName(o)[0];
		a.async = 1;
		a.src = g;
		m.parentNode.insertBefore(a, m)
	})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

	ga('create', 'UA-46755880-1', 'meanjs.org');
	ga('send', 'pageview');
	</script>
</body>

</html>